function eq(a, b, aStack, bStack) {
    if (a === b) 
        return a !== 0 || 1 / a === 1 / b
    
    if (a !== a) return b !== b
    
    if (a === null || b === null) 
        return false 

    // 由于上面已经比较出来a !== b，所以，如果a不是普通类型，那么返回false
    let type = typeof a
    if (type !== 'object' && type !== 'function' && typeof b !== 'object')
        return false
    
    return deepEq(a, b, aStack, bStack)
}

function deepEq(a, b, aStack, bStack) {
    let toString = Object.prototype.toString 
    let className = toString.call(a)

    // a和b不是同一个类型的
    if (className !== toString.call(b))
        return false

    switch (className) {
        case '[object Number]':
            if (a === b) return a !== 0 || 1 / a === 1 / b
            if (a !== a) return b !== b // NaN
        case '[object String]':
            return '' + a === '' + b
        case '[object Date]':
        case '[object RegExp]':
            return +a === +b
    }

    aStack = aStack || []
    bStack = bStack || []

    // 检查循环引用的情况
    let length = aStack.length
    while(length--) {
        if (aStack[length] === a) return bStack[length] === b
    }

    let isArray = className === '[object Array]'
    if (!isArray) {
        let aCtor = a.Constructor
        let bCtor = b.Constructor

        /**
         * a存在构造函数，同时，a的构造函数不等于b的构造函数
         * 针对以下情况：
         * let Man = function (name) {
         *  this.name = name
         * }
         * 
         * let Woman = function (name) {
         *  this.name = name
         * }
         * 
         * let man = new Man("jack") // {"name": "jack"}
         * let woman = new Woman("jack") // {"name": "jack"}
         * 
         * man和woman的键值相同，但是，man和woman是不同的类所生成的对象，此时，他们的Constructor是不同的
         */
        if (
            aCtor !== bCtor && 
            !(
                isFunction(aCtor) && 
                aCtor instanceof aCtor && 
                isFunction(bCtor) && 
                bCtor instanceof bCtor
            ) && 
            ('constructor' in a && 'constructor' in b)
        ) {
            return false;
        }
    }

    aStack.push(a)
    bStack.push(b) 

    if (isArray) {
        if (a.length !== b.length) return false
        let len = a.length
        while (len--) {
            if (!eq(a[len], b[len], aStack, bStack)) return false
        }
    } else {
        let keys = Object.keys(a)
        if (keys.length !== Object.keys(b).length) return false
        for (let key of keys) {
            if (!b.hasOwnProperty(key) || !eq(a[key], b[key], aStack, bStack)) return false
        }
    }

    // 
    aStack.pop()
    bStack.pop()
    // console.log("aStack = ", aStack)
    // console.log("bStack = ", bStack)

    return true
}